# StoreApi 인터페이스 분석

## 1. 이 코드의 역할
`StoreApi<T>`는 zustand의 store가 반드시 제공해야 하는 **최소 기능 집합**을 정의한 인터페이스다.

이 인터페이스는 다음 네 가지 기능만을 정의한다.  
- 상태를 변경하는 기능
- 현재 상태를 조회하는 기능
- 초기 상태를 보존하고 조회하는 기능
- 상태 변경을 외부에서 감지할 수 있게 하는 기능  

즉, store의 구현 방식이나 사용 환경과는 분리된 채,  
zustand store가 **무엇을 할 수 있어야 하는지**만을 정의한다.  

## 2. 구현에서 눈에 띄는 점
### ① 상태 변경 로직을 setState 하나로 제한
```
setState: SetStateInternal<T>
```
**설명**
- store의 내부 상태를 변경할 수 있는 유일한 통로
- 내부 구현이 어떤 방식이든 상태 변경은 반드시 이 메서드를 거치도록 설계됨  

이를 통해 zustand는 상태 변경 규칙을 한 지점으로 집중시키고,  
타입 시스템을 통해 잘못된 호출을 컴파일 타임에 차단하는 방법이 인상 깊었다.

### ② 조회 API가 “현재 상태”와 “초기 상태”로 명확히 분리됨  
```
getState: () => T
getInitialState: () => T
```
**설명**
- `getState`: 현재 시점의 상태 조회  
- `getInitialState`: store 생성 시점의 상태 조회  

초기 상태를 별도의 API로 분리한 점에서  
zustand는 **상태의 시간적 기준(현재 / 초기)**을 중요하게 다루고 있는 것 같다.  

### ③ subscribe가 커링 형태의 함수로 정의됨
```
subscribe: (listener: (state: T, prevState: T) => void) => () => void
```
**설명** 
- `subscribe`의 반환값이 또다른 함수라는 점이 눈에 띈다.

구체적인 내부 동작은 알 수 없지만,  
`setInterval`이 정리를 위한 ID를 반환하는 것처럼  
이 구조 역시 **구독을 해제하기 위한 수단을 반환하는 패턴**임을 타입 수준에서 암시하는 것 같아 눈에 띄었다.

## 3. 왜 이렇게 설계했을까?
`StoreApi`는 가능한 한 **역할을 되도록 최소화한 인터페이스**로 보인다.
- 상태 변경의 복잡성 → `SetStateInternal<T>`로 위임
- 구독 로직의 구현 → 인터페이스 외부에서 책임
- store의 핵심 기능만 노출

이로 인해 `StoreApi`는 zustand 전체에서 **기준점** 역할을 하게끔 설계된 것 같다.

## 4. 내가 만약 직접 만들었다면?
나 역시 store의 모든 기능을 하나의 인터페이스에 담기보다는,  
가장 중요한 핵심 기능만을 추려 인터페이스로 분리했을 것 같다.

## 5. 이 코드에서 배운 점
라이브러리의 핵심 인터페이스는 작을수록 좋다