# SetStateInternal 타입 분석

## 1. 이 코드의 역할
`SetStateInternal<T>`는 zustand store에서 사용되는 `setState` 함수의  
**실제 호출 시그니처를 정의하는 타입**이다.  

- 상태 전체를 교체하는 경우
- 상태 일부만 병합하는 경우
- 현재 상태를 기준으로 다음 상태를 계산하는 경우  

이러한 경우들을 타입 수준에서 명확히 구분하여
잘못된 호출을 **컴파일 타임에 차단**하는 역할을 한다.  

즉, `setState`의 모든 사용 패턴을 하나의 타입 안에 안전하게 담아낸  
**zustand 상태 업데이트 모델의 핵심 타입**이다.  

## 2. 구현에서 눈에 띄는 점
### ① 함수 오버로드를 객체 타입으로 감싼 구조
```
{
  _(...): void
  _(...): void
}['_']
```
**설명**  
- 같은 이름(`_`)의 메서드를 여러번 선언하여 함수 오버로드를 구현
- 이후 `['_']`로 해당 메서드 타입만 추출
=> 결과적으로 **오버로드된 함수 타입 하나**를 얻는 구조  

```
interface SetState<T> {
  (partial: ...): void
  (state: ..., replace: true): void
}
```

위 코드처럼 `interface`로도 함수 오버로드를 구현할 수 있지만,  
이 경우 제네릭 전달이나 조건부 타입과 결합될 때 타입 추론이 불안정해질 수 있다.  

객체 + indexed access 방식은 이러한 문제를 피하면서  
**보다 안정적인 타입 추론**을 제공한다는 점이 인상 깊었다.

### ② `replace` 플래그를 boolean literal 타입으로 분리
```
(partial, replace?: false)
(state, replace: true)
```
**설명** 
- `replace`가 없거나 `false`일 때: partial update
- `replace`가  `true`일 때: 전체 state 교체  

단순히 `replace?: boolean`으로 처리하지 않고,  
**`ture` / `false`를 literal 타입으로 고정**해 호출 패턴을 명확히 분리한 점이 인상 깊었다.

### ③ updater 함수를 객체에 감싸서 타입을 추출하는 패턴
```
{ _(state: T): T | Partial<T> }['_']
```
**설명** 
- updater 함수 타입을 직접 쓰지 않고 객체에 한 번 감싼 뒤 추출
- 복잡한 오버로드 + 제네릭 조합에서도 타입 추론이 깨지지 않도록 설계

```
(state: T) => T | Partial<T>
```
위와 같이 직접 함수 타입을 사용할 수도 있다고 생각했지만,  
TypeScript는 오버로드와 조건부 타입이 결합될 경우 함수 타입을 직접 사용하면 추론이 깨지는 경우가 있다.  

이러한 문제를 피하기 위해  
라이브러리 레벨에서 **객체 + indexed access 방식을 통해 안정적으로 타입을 추출하는 방식**을  
떠올리고 사용했다는 점이 인상 깊었다.

## 3. 왜 이렇게 설계했을까?
`setState`의 여러 상태 업데이트 패턴들을 모두 허용하면서도, 
잘못된 사용은 **타입 단계에서 차단**하기 위해 이런 구조로 설계했을 것이다.

```
setState(state: T | Partial<T>, replace?: boolean)
```
만약 위처럼 단순하게 정의했다면  
`replace = true`인 상태에서 `Partial<T>`를 넘기는 실수를 타입으로 막을 수 없다.  

이 경우 문제는 런타임에서만 드러났을 것이다.

하지만 zustand는 **replace 모드**에서는 반드시 전체 state만 허용하고,  
**merge 모드**에서는 partial update를 자유롭게 허용하는 규칙을 타입 시스템 단계에서 강제했다.  

그 결과 API는 단순하지만 내부 규칙은 엄격한 함수가 됐다.

## 4. 내가 만약 직접 만들었다면?
내가 직접 만들었다면  
각 상태 업데이트 패턴을 하나씩 분리해 정의하면서  
타입이 길어지고 분기점도 많아졌을 것이다.  

이 경우 코드가 복잡해질 뿐 아니라,  
한 번 타입 오류가 발생하면 어느 분기에서 문제가 생겼는지 추적하기도 어려웠을 것 같다.  

## 5. 이 코드에서 배운 점
- `['_']`와 같은 indexed access 타입 활용 방법을 배웠다. 
- 함수 오버로드는 `interface` 뿐만 아니라 **객체 + indexed access 방식으로도 표현할 수 있다.
