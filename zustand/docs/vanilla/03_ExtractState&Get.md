# ExtractState & Get 타입 분석

## 1. 이 코드의 역할
`ExtractState`와 `Get`은 zustand store의 **구현을 정의하는 타입이 아니라,**  
store를 **타입 레벨에서 안전하게 읽기 위한 유틸 타입**이다.  
- `ExtractStore`  
: store처럼 보이는 객체로부터 **상태(state) 타입을 추출하는 역할**을 한다.
- `Get`  
: 추출된 상태(또는 객체 타입)에서 **특정 key에 접근 가능한지 판단하고,** 그 결과를 타입으로 반환한다.  

## 2. 구현에서 눈에 띄는 점
### ① 조건부 타입에서의 extends 사용 방식
```
type ExtractState<S> =
  S extends { getState: () => infer T } ? T : never
```
**설명**
기존에는 `extends`를 주로 다음과 같은 용도로만 사용해왔다.  
```
interface B extends A {}
type Foo<T extends string> = T
```
- 인터페이스 상속
- 제네릭 타입의 제약 조건

하지만 `ExtractState`의 `extends`는 확장이나 제한이 아니라,  
**형태를 검사하는 조건식**으로 사용된다.  
```
S extends { getState: () => infer T }
```
이 구문은 "S라는 타입이 `getState(): 어떤 타입`이라는 메서드를 가질 수 있는가?"를 묻는  
**타입 레벨의 if 조건**에 가깝다.  

여기서 중요한 점은 `S`가 정확히 이 타입일 필요는 없고,  
이 구조를 **포함할 수 있으면 조건을 만족한다**는 점이다.  

즉, 이 `extends`는 **타입을 확장하는 문법이 아니라, 구조적 타입 시스템을 이용한 조건 검사**라는 점이 인상 깊었다.  

### ② 실패 케이스를 never로 명확히 고정한 점
**설명**  
조건을 만족하지 못했을 때의 결과로  
`undefined`나 `unknown`이 아니라 **`never`를 사용한 점**이 눈에 띄었다.  
- `undefined`: 값이 있을 수도 있다는 여지  
- `unknown`: 타입은 있지만 모를 뿐이라는 여지  

반면 `never`는 **"이 타입은 잘못됐다."** 라는 의미를 가진다.  

즉, `never`를 사용하면서 실패를 타입 시스템에서 즉시 드러내도록 설계한 구조로 볼 수 있다.  

### ③ S extends ... ? T : never 구조 자체가 하나의 패턴
```
S extends ... ? T : never
```
**설명**  
이 구조는 단순한 문법 선택이 아니라,  
유틸 타입의 책임을 명확히 드러내는 패턴처럼 느껴졌다.  

이 타입의 역할을 문장으로 풀어보면 다음과 같다.  
> "store처럼 보이면 상태를 꺼내고, 그렇지 않으면 타입 계산을 실패시킨다."

이 패턴 덕분에 잘못된 타입은 이후 로직으로 흘러가지 않고,  
타입 레벨에서 즉시 피드백을 받게 된다.  

### ④ Get 타입에서 실패 타입을 외부로 위임한 구조
```
type Get<T, K, F> = K extends keyof T ? T[K] : F
```
**설명**
처음에 이 타입을 봤을 때는 다음과 같이 작성할 수도 있었을 것 같았다.  
```
type LooseGet<T, K> = K extends keyof T ? T[K] : never
```
하지만 이 경우 모든 실패가 `never`로 고정되어 의미가 동일해지고,  
타입 조합을 하는 쪽에서 의도를 표현할 수 없게 되어 버린다.  

`Get`은 이를 피하기 위해 **실패 시 반환할 타입을 `F`로 외부에서 받는다.** 

이 구조로 인해 `Get`은 **“이 key가 유효한지만 알려주는 최소 단위 유틸”** 역할만 수행하고,  
실패의 의미는 **사용하는 쪽에서 결정한다**라는 명확한 역할 분리가 가능해진다.  

## 3. 왜 이렇게 설계했을까?
이 두 타입은 공통적으로 **"라이브러리 내부의 구현보다, 외부에서의 사용과 조합을 고려한 설계"** 로 보인다.  

즉, 두 타입 모두 판단은 내부에서, 의미 부여는 외부에서 하도록 명확히 역할을 나눈 구조로 보인다.  

## 4. 내가 만약 직접 만들었다면?
처음 접근했다면 아마 `ExtractState`는 `StoreApi<T>`를 직접 extends하거나  
`Get`은 실패 시 `never`로 고정했을 것 같다.  

하지만 이런 방식은 타입 조합이 빡빡해지고 중간 단계에서 유연한 확장이 어려웠을 것이다.

## 5. 이 코드에서 배운 점
- `extends`는 제약뿐 아니라 조건 검사로도 활용될 수 있다.
- `never`는 실패를 명확히 드러내는 도구다.
- 타입 유틸에서는 **"무엇을 반환하느냐"보다 "어디서 실패시키고, 실패의 의미를 누가 결정하느냐"가 더 중요할 수 있다.**