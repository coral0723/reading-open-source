# ReadonlyStoreApi 타입 분석

## 1. 이 코드의 역할
`StoreApi<T>` 전체를 노출하지 않고,  
**React 훅이 동작하는 데 필요한 최소한의 인터페이스만 추려낸 타입**이다.  

상태를 읽을 수 있고(getState),  
초기 상태를 읽을 수 있고(getInitialState),  
변경을 구독할 수 있는(subscribe)  
"읽기 + 구독"만 가능한 Store 계약을 정의한다.  

여기서는 아직 React와의 연결은 등장하지 않았지만,  
**React가 외부 store를 구독하기 위한 최소 조건을 타입으로 미리 좁혀두는 작업**으로 볼 수 있다.   

## 2. 구현에서 눈에 띄는 점
### ① Pick을 사용한 점
새로운 타입을 직접 정의하지 않고,  
기존 `StoreApi<T>`에서 일부만 선택했다.  

즉, 구조를 다시 설계한 것이 아니라 기존 계약의 일부를 의도적으로 축소한 것이다.  

### ② setState가 포함되지 않은 점
`StoreApi`에는 분명 `setState`도 존재하는데,  
여기서는 의도적으로 제외되었다.  

이건 단순한 생략이라기보다는  
"React 훅이 store를 변경할 필요가 없다"는 암묵적인 설계 의도가 느껴진다.  

## 3. 왜 이렇게 설계했을까?
아직 react.ts의 나머지 코드들을 읽지 않은 상태에서 추축해보면  
React는 상태를 읽고 변경을 감지한 다음 리렌더링하는 역할이라 상태를 직접 변경하는 책임이 없어서  
`setState`가 불필요하다고 판단했을 것 같다.  

## 4. 내가 만약 직접 만들었다면?
```
type ReadonlyStoreApi<T> = Omit<
  StoreApi<T>,
  'setState'
>
```
`react-optimistic-chat`에서 사용자 데이터의 id, role, content에 매핑한 필드를 제외한 필드들을 custom 영역으로 분리하기 위해 Omit을 사용한 것처럼,  
여기에서도 타입 선언을 조금 더 간결하게 만들기 위해 `Omit`을 선택했을 것 같다.  

또한 `setState`만 명확히 제거함으로써,  
상태 변경을 다루지 않는다는 의도를 직접적으로 드러내고자 했을 것 같다.  

다만 해당 코드를 다시 보니,  
이 방식은 "무엇을 제거했는지"는 분명하지만,  
"무엇만을 사용하겠다"는 드러나지 않는다.  

이 점에서 최소 계약을 명시적으로 선언하는 방식이 의도를 전달하기에 더 효과적이라는 걸 느꼈다.  

## 5. 이 코드에서 배운 점
4번의 내용
